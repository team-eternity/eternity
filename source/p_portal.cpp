//
// The Eternity Engine
// Copyright (C) 2025 Stephen McGranahan et al.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see http://www.gnu.org/licenses/
//
//------------------------------------------------------------------------------
//
// Purpose: Linked portals.
// Authors: Stephen McGranahan, James Haley, Ioan Chera, Max Waine
//

#include "z_zone.h"

#include "c_io.h"
#include "doomstat.h"
#include "e_exdata.h"
#include "ev_specials.h"
#include "m_bbox.h"
#include "m_intmap.h"
#include "p_chase.h"
#include "polyobj.h"
#include "p_portal.h"
#include "p_portalblockmap.h"
#include "p_setup.h"
#include "p_slopes.h"
#include "p_user.h"
#include "r_main.h"
#include "r_portal.h"
#include "r_state.h"
#include "v_misc.h"

//
// Polyobject-generated sector couple. The couple is between the external box sector which houses
// the polyobject prototype in the editor, and the spawn spot sector in the game world. This
// information is needed when flood-filling the portal layers with P_GatherSectors, to ensure that
// the box sector is assigned the correct group ID.
//
struct polycouple_t
{
    sector_t *sectors[2]; // the two linked sectors.
    int       polyid;
};

// SoM: Linked portals
// This list is allocated PU_LEVEL and is nullified in P_InitPortals. When the
// table is built it is allocated as a linear buffer of groupcount * groupcount
// entries. The entries are arranged much like pixels in a screen buffer where
// the offset is located in linktable[startgroup * groupcount + targetgroup]
linkoffset_t **linktable = nullptr;

// This guy is a (0, 0, 0) link offset which is used to populate null links in the
// linktable and is returned by P_GetLinkOffset for invalid inputs
linkoffset_t zerolink = { 0, 0, 0 };

static int groupcount = 0;

static int *clusters; // the portal clusters, used when portals move with polys.

// This flag is a big deal. Heh, if this is true a whole lot of code will
// operate differently. This flag is cleared on P_PortalInit and is ONLY to be
// set true by P_BuildLinkTable.
bool useportalgroups = false;

// ioanch 20160109: needed for sprite projecting
bool  gMapHasSectorPortals;
bool  gMapHasLinePortals; // ioanch 20160131: needed for P_UseLines
bool *gGroupVisit;
// ioanch 20160227: each group may have a polyobject owner
const polyobj_t **gGroupPolyobject;

static PODCollection<polycouple_t> gPolyCouples;
static IntListMap                  gGroupSectors;
static bool                       *gPolyGroupPairs; // pairs of groupIDs generated by polys

static DualIntListMap gSectorNeighborsThroughPortals;

//
// Adds a unique new poly couple set.
//
static void P_addPolyCouple(int polyid, sector_t &sector1, sector_t &sector2)
{
    // Check if already present
    sector_t           &firstsector  = &sector1 < &sector2 ? sector1 : sector2;
    sector_t           &secondsector = &sector1 > &sector2 ? sector1 : sector2;
    const polycouple_t *couple;
    for(couple = gPolyCouples.begin(); couple != gPolyCouples.end(); ++couple)
        if(couple->sectors[0] == &firstsector && couple->sectors[1] == &secondsector)
            break;
    if(couple != gPolyCouples.end())
        return;
    gPolyCouples.add(polycouple_t{
        { &firstsector, &secondsector },
        polyid
    });
}

//
// Checks if a poly couple with polyid was already added.
//
// NOTE: it's sufficient for either the poly id to be listed or the control sector. It means they
// already got connected to the main world.
//
static bool P_isPolyCoupleAdded(int polyid, const sector_t &polyobjControlSector)
{
    for(const polycouple_t &couple : gPolyCouples)
        if(couple.polyid == polyid || couple.sectors[0] == &polyobjControlSector ||
           couple.sectors[1] == &polyobjControlSector)
            return true;
    return false;
}

//
// Checks if this sector has a partner.
//
static sector_t *P_findCouplePartner(const sector_t &sector)
{
    for(const polycouple_t &couple : gPolyCouples)
    {
        if(couple.sectors[0] == &sector)
            return couple.sectors[1];
        if(couple.sectors[1] == &sector)
            return couple.sectors[0];
    }
    return nullptr;
}

//
// P_PortalGroupCount
//
int P_PortalGroupCount()
{
    return useportalgroups ? groupcount : 1;
}

//
// P_InitPortals
//
// Called before map processing. Simply inits some module variables
void P_InitPortals(void)
{
    linktable = nullptr;

    groupcount = 0;

    useportalgroups = false;
}

//
// R_SetSectorGroupID
//
// SoM: yes this is hackish, I admit :(
// This sets all mobjs inside the sector to have the sector id
// FIXME: why is this named R_ instead p_portal?
//
void R_SetSectorGroupID(sector_t *sector, int groupid)
{
    sector->groupid = groupid;

    // SoM: soundorg ids need to be set too
    sector->soundorg.groupid  = groupid;
    sector->csoundorg.groupid = groupid;

    // haleyjd 12/25/13: must scan thinker list, not use sector thinglist.
    for(auto th = thinkercap.next; th != &thinkercap; th = th->next)
    {
        Mobj *mo;
        if((mo = thinker_cast<Mobj *>(th)))
        {
            if(mo->subsector && mo->subsector->sector == sector)
                mo->groupid = groupid;
        }
    }

    // haleyjd 04/19/09: propagate to line sound origins
    for(int i = 0; i < sector->linecount; ++i)
        sector->lines[i]->soundorg.groupid = groupid;
}

//
// P_CreatePortalGroup
//
// This function creates a new portal group using the given sector as the
// starting point for the group. P_GatherSectors is then called to gather
// sectors into the group, and the newly created id is returned.
//
int P_CreatePortalGroup(sector_t *from)
{
    int groupid = groupcount;

    if(from->groupid != R_NOGROUP)
        return from->groupid;

    groupcount++;

    P_GatherSectors(from, groupid);
    return groupid;
}

//
// P_GatherSectors
//
// The function will run through the sector's lines list, and add
// attached sectors to the group's sector list. As each sector is added the
// currently forming group's id is assigned to that sector. This will continue
// until every attached sector has been added to the list, thus defining a
// closed subspace of the map.
//
void P_GatherSectors(sector_t *from, const int groupid)
{
    static sector_t **list    = nullptr;
    static int        listmax = 0;

    sector_t *sec2;
    line_t   *line;
    int       count = 0;
    int       i, sec;

    if(groupid < 0 || groupid >= groupcount)
    {
        // I have no idea if/when this would ever happen, but at any rate, it
        // would translate to EE itself doing something wrong.
        I_Error("P_GatherSectors: groupid invalid!");
    }

    // Sector already has a group
    if(from->groupid != R_NOGROUP)
        return;

    // SoM: Just check for a null list here.
    if(!list || listmax <= numsectors)
    {
        listmax = numsectors + 1;
        list    = erealloc(sector_t **, list, sizeof(sector_t *) * listmax);
    }

    R_SetSectorGroupID(from, groupid);
    list[count++] = from;

    auto visit = [&count, groupid](sector_t *sec2) {
        int p;
        for(p = 0; p < count; ++p)
        {
            if(sec2 == list[p])
                break;
        }
        // if we didn't find the sector in the list, add it
        if(p == count)
        {
            list[count++] = sec2;
            R_SetSectorGroupID(sec2, groupid);
        }
    };

    for(sec = 0; sec < count; ++sec)
    {
        from = list[sec];

        for(i = 0; i < from->linecount; ++i)
        {
            // add any sectors to the list which aren't already there.
            line = from->lines[i];
            if((sec2 = line->frontsector))
                visit(sec2);

            if((sec2 = line->backsector))
                visit(sec2);
        }

        // Now check coupled sectors
        if((sec2 = P_findCouplePartner(*from)))
            visit(sec2);
    }
}

//
// P_GetLinkOffset
//
// This function returns a linkoffset_t object which contains the map-space
// offset to get from the startgroup to the targetgroup. This will always return
// a linkoffset_t object. In cases of invalid input or no link the offset will be
// (0, 0, 0)
//
linkoffset_t *P_GetLinkOffset(int startgroup, int targetgroup)
{
    if(!useportalgroups)
        return &zerolink;

    if(!linktable)
    {
        C_Printf(FC_ERROR "P_GetLinkOffset: called with no link table.\n");
        return &zerolink;
    }

    if(startgroup < 0 || startgroup >= groupcount)
    {
        C_Printf(FC_ERROR "P_GetLinkOffset: called with OoB start groupid %d.\n", startgroup);
        return &zerolink;
    }

    if(targetgroup < 0 || targetgroup >= groupcount)
    {
        C_Printf(FC_ERROR "P_GetLinkOffset: called with OoB target groupid %d.\n", targetgroup);
        return &zerolink;
    }

    auto link = linktable[startgroup * groupcount + targetgroup];
    return link ? link : &zerolink;
}

//
// P_GetLinkIfExists
//
// Returns a link offset to get from 'fromgroup' to 'togroup' if one exists.
// Returns nullptr otherwise
//
linkoffset_t *P_GetLinkIfExists(int fromgroup, int togroup)
{
    if(!useportalgroups)
        return nullptr;

    if(!linktable)
    {
        C_Printf(FC_ERROR "P_GetLinkIfExists: called with no link table.\n");
        return nullptr;
    }

    if(fromgroup < 0 || fromgroup >= groupcount)
    {
        C_Printf(FC_ERROR "P_GetLinkIfExists: called with OoB fromgroup %d.\n", fromgroup);
        return nullptr;
    }

    if(togroup < 0 || togroup >= groupcount)
    {
        C_Printf(FC_ERROR "P_GetLinkIfExists: called with OoB togroup %d.\n", togroup);
        return nullptr;
    }

    return linktable[fromgroup * groupcount + togroup];
}

//
// P_AddLinkOffset
//
// Returns 0 if the link offset was added successfully, 1 if the start group is
// out of bounds, and 2 of the target group is out of bounds.
//
static int P_AddLinkOffset(int startgroup, int targetgroup, const v3fixed_t &v)
{
    linkoffset_t *link;

#ifdef RANGECHECK
    if(!linktable)
        I_Error("P_AddLinkOffset: no linktable allocated.\n");
#endif

    if(startgroup < 0 || startgroup >= groupcount)
        return 1;
    // I_Error("P_AddLinkOffset: start groupid %d out of bounds.\n", startgroup);

    if(targetgroup < 0 || targetgroup >= groupcount)
        return 2;
    // I_Error("P_AddLinkOffset: target groupid %d out of bounds.\n", targetgroup);

    if(startgroup == targetgroup)
        return 0;

    link = emalloctag(linkoffset_t *, sizeof(linkoffset_t), PU_LEVEL, nullptr);
    linktable[startgroup * groupcount + targetgroup] = link;

    *link = v;

    return 0;
}

//
// P_CheckLinkedPortal
//
// This function performs various consistency and validation checks.
//
static bool P_CheckLinkedPortal(portal_t *const portal, sector_t *sec)
{
    int i = eindex(sec - sectors);

    if(!portal || !sec)
        return true;
    if(portal->type != R_LINKED)
        return true;

    const linkdata_t &ldata = portal->data.link;
    if(ldata.toid == sec->groupid)
    {
        C_Printf(FC_ERROR "P_BuildLinkTable: sector %i portal references the "
                          "portal group to which it belongs.\n"
                          "Linked portals are disabled.\a\n",
                 i);
        return false;
    }

    if(ldata.fromid < 0 || ldata.fromid >= groupcount || ldata.toid < 0 || ldata.toid >= groupcount)
    {
        C_Printf(FC_ERROR "P_BuildLinkTable: sector %i portal has a groupid out "
                          "of range.\nLinked portals are disabled.\a\n",
                 i);
        return false;
    }

    if(sec->groupid < 0 || sec->groupid >= groupcount)
    {
        C_Printf(FC_ERROR "P_BuildLinkTable: sector %i does not belong to a "
                          "portal group.\nLinked portals are disabled.\a\n",
                 i);
        return false;
    }

    if(sec->groupid != ldata.fromid)
    {
        C_Printf(FC_ERROR "P_BuildLinkTable: sector %i does not belong to the "
                          "portal's fromid\nLinked portals are disabled.\a\n",
                 i);
        return false;
    }

    auto link = linktable[sec->groupid * groupcount + ldata.toid];

    // We've found a linked portal so add the entry to the table
    if(!link)
    {
        int ret = P_AddLinkOffset(sec->groupid, ldata.toid, ldata.delta);
        if(ret)
            return false;
    }

    return true;
}

//
// P_GatherLinks
//
// This function generates linkoffset_t objects for every group to every other
// group, that is, if group A has a link to B, and B has a link to C, a link
// can be found to go from A to C.
//
static void P_GatherLinks(int group, const v3fixed_t &dv, int via)
{
    int           i, p;
    linkoffset_t *link, **linklist, **grouplinks;

    // The main group has an indrect link with every group that links to a group
    // that has a direct link to it, or any group that has a link to a group the
    // main group has an indirect link to. huh.

    // First step: run through the list of groups this group has direct links to
    // from there, run the function again with each direct link.
    if(via == R_NOGROUP)
    {
        linklist = linktable + group * groupcount;

        for(i = 0; i < groupcount; ++i)
        {
            if(i == group)
                continue;

            if((link = linklist[i]))
                P_GatherLinks(group, *link, i);
        }

        return;
    }

    linklist   = linktable + via * groupcount;
    grouplinks = linktable + group * groupcount;

    // Second step run through the linked group's link list. Ignore any groups
    // the main group is already linked to. Add the deltas and add the entries,
    // then call this function for groups the linked group links to.
    for(p = 0; p < groupcount; ++p)
    {
        if(p == group || p == via)
            continue;

        if(!(link = linklist[p]) || grouplinks[p])
            continue;

        P_AddLinkOffset(group, p, dv + *link);
        P_GatherLinks(group, dv + *link, p);
    }
}

//
// Fit the link offset to a portal
//
void P_FitLinkOffsetsToPortal(const linkdata_t &ldata)
{
    linkoffset_t *offset = P_GetLinkOffset(ldata.fromid, ldata.toid);
    // Move the "fromid" group because the crossing actor is now in "toid".
    v3fixed_t shift = { ldata.delta.x - offset->x, ldata.delta.y - offset->y, ldata.delta.z - offset->z };
    if(!shift.x && !shift.y && !shift.z)
        return;

    bool *groupvisit = ecalloc(bool *, sizeof(bool), groupcount);
    P_MoveGroupCluster(ldata.fromid, ldata.toid, groupvisit, -shift.x, -shift.y, false, nullptr);
    efree(groupvisit);
}

static void P_GlobalPortalStateCheck()
{
    sector_t *sec;
    line_t   *line;
    int       i;

    for(i = 0; i < numsectors; i++)
    {
        sec = sectors + i;

        if(sec->srf.ceiling.portal)
            P_CheckSectorPortalState(*sec, surf_ceil);
        if(sec->srf.floor.portal)
            P_CheckSectorPortalState(*sec, surf_floor);
    }

    for(i = 0; i < numlines; i++)
    {
        line = lines + i;

        if(line->portal)
            P_CheckLPortalState(line);
    }
}

//
// Determines the sectors beyond a surface portal, which can be several.
// It works by assuming that there'll be an exact shape on the other side (otherwise there's HOM),
// which may contain more divisions.
//
// Only for surface (floor/ceiling) portals.
//
// Only to be called during level initialization; meant to be comprehensive (via a defined limit),
// not fast.
//
static void P_findSectorNeighborsViaSurfacePortal(const sector_t &source, const portal_t &portal,
                                                  PODCollection<int> &coll)
{
    if(portal.type != R_LINKED || source.linecount <= 0)
        return; // only for linked portals (or shapeless sectors)

    int tgroupid = portal.data.link.toid;

    fixed_t bbox[4];
    M_ClearBox(bbox);
    for(int i = 0; i < source.linecount; ++i)
    {
        const line_t &line = *source.lines[i];
        M_AddToBox2(bbox, line.bbox[BOXLEFT], line.bbox[BOXBOTTOM]);
        M_AddToBox2(bbox, line.bbox[BOXRIGHT], line.bbox[BOXTOP]);
    }

    // We now have the bounding box. Translate it.
    const linkdata_t &link  = portal.data.link;
    bbox[BOXLEFT]          += link.delta.x;
    bbox[BOXBOTTOM]        += link.delta.y;
    bbox[BOXRIGHT]         += link.delta.x;
    bbox[BOXTOP]           += link.delta.y;

    // Now convert it to blockmap
    int blockbox[4];
    blockbox[BOXLEFT] = (bbox[BOXLEFT] - bmaporgx) >> MAPBLOCKSHIFT;
    if(blockbox[BOXLEFT] < 0)
        blockbox[BOXLEFT] = 0;
    blockbox[BOXBOTTOM] = (bbox[BOXBOTTOM] - bmaporgy) >> MAPBLOCKSHIFT;
    if(blockbox[BOXBOTTOM] < 0)
        blockbox[BOXBOTTOM] = 0;
    blockbox[BOXRIGHT] = (bbox[BOXRIGHT] - bmaporgx) >> MAPBLOCKSHIFT;
    if(blockbox[BOXRIGHT] >= bmapwidth)
        blockbox[BOXRIGHT] = bmapwidth - 1;
    blockbox[BOXTOP] = (bbox[BOXTOP] - bmaporgy) >> MAPBLOCKSHIFT;
    if(blockbox[BOXTOP] >= bmapheight)
        blockbox[BOXTOP] = bmapheight - 1;

    //
    // Local context
    //
    struct ctx_t
    {
        const sector_t     &source;
        const linkdata_t   &link;
        PODCollection<int> &neighs;
    };
    ctx_t ctx = { source, link, coll };

    // Now scan all lines, as long as they belong to the right groupid
    ++validcount;
    for(int by = blockbox[BOXBOTTOM]; by <= blockbox[BOXTOP]; ++by)
    {
        for(int bx = blockbox[BOXLEFT]; bx <= blockbox[BOXRIGHT]; ++bx)
        {
            P_BlockLinesIterator(
                bx, by,
                [](line_t *line, polyobj_t *po, void *context) {
                    if(!line->dx && !line->dy) // must avoid degenerate lines, division by 0
                        return true;
                    sector_t *const targsectors[2] = { line->frontsector, line->backsector };
                    if(targsectors[0]->validcount == validcount &&
                       (!targsectors[1] || targsectors[1]->validcount == validcount))
                    {
                        return true; // both sectors already visited
                    }

                    // Get how they'd be placed on our source sector
                    v2fixed_t mid   = { line->v1->x + line->dx / 2, line->v1->y + line->dy / 2 };
                    v2fixed_t nudge = P_GetSafeLineNormal(*line) / (1 << (FRACBITS - 8));

                    auto     &ctx    = *static_cast<ctx_t *>(context);
                    auto      delta  = v2fixed_t(ctx.link.delta);
                    v2fixed_t ov[2]  = { mid + nudge - delta, mid - nudge - delta };
                    bool      gotOne = false;
                    for(int i = 0; i < 2; ++i)
                    {
                        if(!targsectors[i])
                            continue; // back may of course be missing
                        const subsector_t &ss = *R_PointInSubsector(ov[i]);
                        if(ss.sector == &ctx.source && !P_IsInVoid(ov[i].x, ov[i].y, ss))
                        {
                            gotOne = true; // mark it now if it's on spot
                            if(targsectors[i]->validcount != validcount)
                            {
                                ctx.neighs.add(eindex(targsectors[i] - sectors));
                                targsectors[i]->validcount = validcount;
                            }
                        }
                    }
                    if(!gotOne)
                    {
                        // Now also check intersection
                        // Need to shorten them a bit to clear out edge cases
                        ov[0] = v2fixed_t{ line->v1->x, line->v1->y } - delta;
                        ov[1] = v2fixed_t{ line->v2->x, line->v2->y } - delta;
                        if(P_SegmentIntersectsSector(ov[0], ov[1], ctx.source))
                            for(int i = 0; i < 2; ++i)
                            {
                                if(!targsectors[i] || targsectors[i]->validcount == validcount)
                                    continue;
                                ctx.neighs.add(eindex(targsectors[i] - sectors));
                                targsectors[i]->validcount = validcount;
                            }
                    }
                    return true;
                },
                tgroupid, &ctx);
        }
    }

    // If no linedef was caught, then it means the entirety of the target place is inside a sector.
    // Pick it going from here.
    if(coll.isEmpty())
    {
        const line_t &line  = *source.lines[0];
        v2fixed_t     mid   = { line.v1->x + line.dx / 2, line.v1->y + line.dy / 2 };
        fixed_t       len   = P_AproxDistance(line.dx, line.dy);
        v2fixed_t     nudge = {
            FixedDiv(line.dy, len) / (1 << (FRACBITS - 8)),
            -FixedDiv(line.dx, len) / (1 << (FRACBITS - 8)),
        };
        if(line.frontsector != &source)
            nudge = -nudge;
        v2fixed_t          delta  = { link.delta.x, link.delta.y };
        v2fixed_t          point  = mid + nudge + delta;
        const subsector_t &ss     = *R_PointInSubsector(point);
        sector_t          &sector = *ss.sector;
        if(sector.groupid == tgroupid && !P_IsInVoid(point.x, point.y, ss))
            coll.add(eindex(&sector - sectors));
    }
}

//
// Initializes sector portal neighbors.
//
void P_initSectorPortalNeighbors()
{
    Collection<PODCollection<int>> neighs[surf_NUM];

    for(int i = 0; i < numsectors; ++i)
    {
        sector_t &sector = sectors[i];

        for(surf_e surf : SURFS)
        {
            PODCollection<int> coll;
            const portal_t    *portal = sector.srf[surf].portal;
            if(portal && portal->type == R_LINKED)
                P_findSectorNeighborsViaSurfacePortal(sector, *portal, coll);

            neighs[surf].add(std::move(coll));
        }
    }

    gSectorNeighborsThroughPortals.load(neighs[surf_floor], neighs[surf_ceil]);
}

static void P_linkDeferredThingsToPortals()
{
    for(Thinker *th = thinkercap.next; th != &thinkercap; th = th->next)
    {
        Mobj *mo = thinker_cast<Mobj *>(th);
        if(!mo)
            continue;
        R_LinkSpriteProj(*mo);
    }
}

//
// P_buildPortalMap
//
// haleyjd 05/17/13: Build a blockmap-like array which will instantly tell
// whether or not a given blockmap cell contains linked portals of different
// types and may therefore need to be subject to differing clipping behaviors,
// such as disabling certain short circuit checks.
//
// ioanch 20151228: also flag for floor and ceiling portals
// ioanch 20210912: generalize this for any portal suprastructure.
//
static void P_buildPortalMap()
{
    size_t pcount = P_PortalGroupCount();
    gGroupVisit   = ecalloctag(bool *, sizeof(bool), pcount, PU_LEVEL, reinterpret_cast<void **>(&gGroupVisit));
    // ioanch 20160227: prepare other groups too
    gGroupPolyobject = ecalloctag(decltype(gGroupPolyobject), sizeof(*gGroupPolyobject), pcount, PU_LEVEL,
                                  reinterpret_cast<void **>(&gGroupPolyobject));

    gMapHasSectorPortals = false; // init with false
    gMapHasLinePortals   = false;

    int writeOfs;
    for(int y = 0; y < bmapheight; y++)
    {
        for(int x = 0; x < bmapwidth; x++)
        {
            int  offset;
            int *list;

            writeOfs = offset = y * bmapwidth + x;
            offset            = *(blockmap + offset);
            list              = blockmaplump + offset;

            // skip 0 delimiter
            ++list;

            // ioanch: also check sector blockmaps
            int *tmplist = list;
            if(*tmplist == -1) // empty blockmap
            {
                // ioanch: in case of no lines in blockmap, determine the sector
                // by looking in the centre
                const sector_t *sector = R_PointInSubsector(::bmaporgx + (x << MAPBLOCKSHIFT) + (MAPBLOCKSHIFT / 2),
                                                            ::bmaporgy + (y << MAPBLOCKSHIFT) + (MAPBLOCKSHIFT / 2))
                                             ->sector;

                if(sector->srf.ceiling.portal && sector->srf.ceiling.portal->type == R_LINKED)
                {
                    portalmap[writeOfs]  |= PMF_CEILING;
                    gMapHasSectorPortals  = true;
                }
                if(sector->srf.floor.portal && sector->srf.floor.portal->type == R_LINKED)
                {
                    portalmap[writeOfs]  |= PMF_FLOOR;
                    gMapHasSectorPortals  = true;
                }
            }
            else
                for(; *tmplist != -1; tmplist++)
                {
                    const line_t &li = lines[*tmplist];
                    if(li.pflags & PS_PASSABLE)
                    {
                        portalmap[writeOfs] |= PMF_LINE;
                        gMapHasLinePortals   = true;
                    }
                    if(li.frontsector->srf.ceiling.portal && li.frontsector->srf.ceiling.portal->type == R_LINKED)
                    {
                        portalmap[writeOfs]  |= PMF_CEILING;
                        gMapHasSectorPortals  = true;
                    }
                    if(li.backsector && li.backsector->srf.ceiling.portal &&
                       li.backsector->srf.ceiling.portal->type == R_LINKED)
                    {
                        portalmap[writeOfs]  |= PMF_CEILING;
                        gMapHasSectorPortals  = true;
                    }
                    if(li.frontsector->srf.floor.portal && li.frontsector->srf.floor.portal->type == R_LINKED)
                    {
                        portalmap[writeOfs]  |= PMF_FLOOR;
                        gMapHasSectorPortals  = true;
                    }
                    if(li.backsector && li.backsector->srf.floor.portal &&
                       li.backsector->srf.floor.portal->type == R_LINKED)
                    {
                        portalmap[writeOfs]  |= PMF_FLOOR;
                        gMapHasSectorPortals  = true;
                    }
                }
        }
    }

    gPortalBlockmap.mapInit();

    P_initSectorPortalNeighbors();

    P_linkDeferredThingsToPortals();
}

//
// Finds sectors coupled with polyobject boxes. Necessary if you want polyobjects
// with portals drawn in disconnected boxes.
//
void P_FindPolyobjectSectorCouples()
{
    // first, empty it
    gPolyCouples.clear();

    static auto findMobj = [](int polyid) -> const Mobj * {
        for(Thinker *th = thinkercap.next; th != &thinkercap; th = th->next)
        {
            const Mobj *mo;
            if((mo = thinker_cast<Mobj *>(th)) && mo->spawnpoint.angle == polyid && Polyobj_IsSpawnSpot(*mo))
            {
                return mo;
            }
        }
        return nullptr;
    };

    for(int i = 0; i < numlines; ++i)
    {
        const line_t &line = lines[i];
        int           type = EV_StaticInitForSpecial(line.special);
        const Mobj   *spot;
        if(type == EV_STATIC_POLYOBJ_START_LINE || type == EV_STATIC_POLYOBJ_EXPLICIT_LINE)
        {
            if(P_isPolyCoupleAdded(line.args[0], *line.frontsector))
                continue;
            spot = findMobj(line.args[0]);
        }
        else
            continue;
        // Replace the group ID now.
        if(spot)
            P_addPolyCouple(line.args[0], *spot->subsector->sector, *line.frontsector);
    }
}

//
// P_BuildLinkTable
//
bool P_BuildLinkTable()
{
    int           i, p;
    sector_t     *sec;
    linkoffset_t *link, *backlink;

    if(!groupcount)
        return true;

    // SoM: the last line of the table (starting at groupcount * groupcount) is
    // used as a temporary list for gathering links.
    linktable = ecalloctag(linkoffset_t **, 1, sizeof(linkoffset_t *) * groupcount * groupcount, PU_LEVEL, nullptr);

    // Run through the sectors check for invalid portal references.
    for(i = 0; i < numsectors; i++)
    {
        sec = sectors + i;

        // Make sure there are no groups that reference themselves or invalid group
        // id numbers.
        if(sec->groupid < R_NOGROUP || sec->groupid >= groupcount)
        {
            C_Printf(FC_ERROR "P_BuildLinkTable: sector %i has a groupid out of "
                              "range.\nLinked portals are disabled.\a\n",
                     i);
            return false;
        }

        if(!P_CheckLinkedPortal(sec->srf.ceiling.portal, sec))
            return false;

        if(!P_CheckLinkedPortal(sec->srf.floor.portal, sec))
            return false;

        for(p = 0; p < sec->linecount; p++)
        {
            if(!P_CheckLinkedPortal(sec->lines[p]->portal, sec))
                return false;
        }
        // Sector checks out...
    }

    // Now the fun begins! Checking the actual groups for correct backlinks.
    // this needs to be done before the indirect link information is gathered to
    // make sure every link is two-way.
    for(i = 0; i < groupcount; i++)
    {
        for(p = 0; p < groupcount; p++)
        {
            if(p == i)
                continue;
            link     = P_GetLinkOffset(i, p);
            backlink = P_GetLinkOffset(p, i);

            // check the links
            if(link && backlink)
            {
                if(backlink->x != -link->x || backlink->y != -link->y || backlink->z != -link->z)
                {
                    C_Printf(FC_ERROR "Portal groups %i and %i link and backlink do "
                                      "not agree\nLinked portals are disabled\a\n",
                             i, p);
                    return false;
                }
            }
        }
    }

    // That first loop has to complete before this can be run!
    for(i = 0; i < groupcount; i++)
        P_GatherLinks(i, {}, R_NOGROUP);

    // SoM: one last step. Find all map architecture with a group id of -1 and
    // assign it to group 0
    for(i = 0; i < numsectors; i++)
    {
        if(sectors[i].groupid == R_NOGROUP)
            R_SetSectorGroupID(sectors + i, 0);
    }

    // Last step is to put zerolink in every link that goes from a group to that same group
    for(i = 0; i < groupcount; i++)
    {
        if(!linktable[i * groupcount + i])
            linktable[i * groupcount + i] = &zerolink;
    }

    // Everything checks out... let's run the portals
    useportalgroups = true;
    P_GlobalPortalStateCheck();

    // haleyjd 05/17/13: mark all blockmap cells where portals live.
    P_buildPortalMap();

    // Check all portals if they fit the link
    for(const portal_t *portal = R_GetPortalHead(); portal; portal = portal->next)
    {
        if(portal->type != R_LINKED)
            continue;
        const linkdata_t   &data = portal->data.link;
        const linkoffset_t *link = P_GetLinkOffset(data.fromid, data.toid);
        if(link->x != data.delta.x || link->y != data.delta.y || link->z != data.delta.z)
        {
            C_Printf("This level is twisted (line %d).\n", portal->data.link.maker);
            break;
        }
    }

    return true;
}

enum
{
    conn_yes         = 1, // groups connected
    conn_polycoupled = 2, // groups are coupled by originating from a same polyobject
};

//
// Flood-fill the clusters matrix
//
static void P_floodFillCluster(const uint8_t *connections, int sourcegroup, int groupid, int *row, int clusterid)
{
    row[groupid] = clusterid;
    for(int i = 0; i < groupcount; ++i)
    {
        if(i == sourcegroup || i == groupid || connections[sourcegroup * groupcount + i] & conn_polycoupled)
        {
            continue;
        }
        if(connections[groupid * groupcount + i] & conn_yes && row[i] == -1)
            P_floodFillCluster(connections, sourcegroup, i, row, clusterid);
    }
}

//
// Marks all clusters of portal groups relative to polyobject vessel groups.
// Needed to have correctly moving polyobjects in relation to separate portals.
//
void P_MarkPortalClusters()
{
    if(!useportalgroups)
        return;

    // FIXME: handle case when groupcount skyrockets
    int  matrixsize = groupcount * groupcount;
    int *clusters   = emalloc(int *, matrixsize * sizeof(int));
    memset(clusters, -1, matrixsize * sizeof(int));
    uint8_t *connections = ecalloc(uint8_t *, matrixsize, sizeof(uint8_t));

    for(const portal_t *portal = R_GetPortalHead(); portal; portal = portal->next)
    {
        if(portal->type != R_LINKED)
            continue;
        // First mark the connections
        connections[portal->data.link.fromid * groupcount + portal->data.link.toid] |= conn_yes;
    }

    // Now check the polyobject-coupled groups
    for(int i = 0; i < numPolyObjects; ++i)
    {
        const polyobj_t &poly = PolyObjects[i];
        for(int j = 0; j < poly.numLines - 1; ++j)
        {
            const line_t &line = *poly.lines[j];
            if(!(line.pflags & PS_PASSABLE))
                continue;
            int ingroup0 = line.portal->data.link.toid;
            for(int k = j + 1; k < poly.numLines; ++k)
            {
                const line_t &line = *poly.lines[k];
                if(!(line.pflags & PS_PASSABLE))
                    continue;
                int ingroup1 = line.portal->data.link.toid;
                if(ingroup1 != ingroup0)
                {
                    connections[ingroup0 * groupcount + ingroup1] |= conn_polycoupled;
                    connections[ingroup1 * groupcount + ingroup0] |= conn_polycoupled;
                }
            }
        }
    }

    // Now we have the connections. Mark the clusters
    for(int i = 0; i < groupcount; ++i)
    {
        int clusterid = 0;
        for(int j = 0; j < groupcount; ++j)
        {
            if(i == j || connections[i * groupcount + j] & conn_polycoupled)
                continue;
            if(connections[i * groupcount + j] & conn_yes && clusters[i * groupcount + j] == -1)
                P_floodFillCluster(connections, i, j, clusters + i * groupcount, clusterid++);
        }
    }

    efree(connections);
    ::clusters = clusters;
    Z_ChangeTag(::clusters, PU_LEVEL);
}

//
// Marks all groupid-pairs joined by polyobjects
//
void P_MarkPolyobjPortalLinks()
{
    gPolyGroupPairs =
        ecalloctag(decltype(gPolyGroupPairs), groupcount * groupcount, sizeof(*gPolyGroupPairs), PU_LEVEL, nullptr);
    for(int i = 0; i < numPolyObjects; ++i)
    {
        const polyobj_t &poly = PolyObjects[i];
        for(size_t j = 0; j < poly.numPortals; ++j)
        {
            if(poly.portals[j]->type != R_LINKED)
                continue;
            const linkdata_t &link = poly.portals[j]->data.link;
            gPolyGroupPairs[link.fromid * groupcount + link.toid] =
                gPolyGroupPairs[link.toid * groupcount + link.fromid] = true;
        }
    }
}

//
// True if the two portal layers are joined by polyobject
//
bool P_PortalLayersByPoly(int groupid1, int groupid2)
{
    return gPolyGroupPairs[groupid1 * groupcount + groupid2];
}

//
// The player passed a line portal from P_TryMove; just update viewport and
// pass-polyobject velocity
//
void P_PortalDidTeleport(Mobj *mo, fixed_t dx, fixed_t dy, fixed_t dz, int fromid, int toid)
{
    // Prevent bad interpolation
    // FIXME: this is not interpolation, it's just instant movement; must be
    // fixed to be real interpolation even for the player (camera)

    // Polyobject car enter and exit inertia
    const polyobj_t *poly[2] = { gGroupPolyobject[fromid], gGroupPolyobject[toid] };
    bool             phave   = false;
    for(int i = 0; i < 2; ++i)
    {
        if(poly[i])
        {
            const auto th = thinker_cast<PolyMoveThinker *>(poly[i]->thinker);
            if(th)
            {
                phave = true;
                break;
            }
            else
            {
                const auto th = thinker_cast<PolySlideDoorThinker *>(poly[i]->thinker);
                if((phave = th && !th->delayCount))
                    break;
            }
        }
    }
    if(phave)
        mo->backupPosition(); // disable mobj portal interpolation for now here

    // SoM: Boom's code for silent teleports. Fixes view bob jerk.
    // Adjust a player's view, in case there has been a height change

    // mo->backupPosition();
    P_AdjustFloorClip(mo);
}

// -----------------------------------------
// Begin portal teleportation
//
// EV_PortalTeleport
//
bool EV_SectorPortalTeleport(Mobj *mo, const linkdata_t &ldata)
{
    if(!mo)
        return 0;

    // ioanch 20160113: don't teleport. Just change x and y
    P_UnsetThingPosition(mo);
    mo->x += ldata.delta.x;
    mo->y += ldata.delta.y;
    mo->z += ldata.delta.z;
    P_SetThingPosition(mo);

    P_PortalDidTeleport(mo, ldata.delta.x, ldata.delta.y, ldata.delta.z, ldata.fromid, ldata.toid);

    return 1;
}

//=============================================================================
//
// SoM: Utility functions
//

//
// P_GetPortalState
//
// Returns the combined state flags for the given portal based on various
// behavior flags
//
static int P_GetPortalState(const portal_t *portal, int sflags, bool obscured)
{
    bool active;
    int  ret = sflags & (PF_FLAGMASK | PS_OVERLAYFLAGS | PO_OPACITYMASK);

    if(!portal)
        return 0;

    active = !obscured && !(portal->flags & PF_DISABLED) && !(sflags & PF_DISABLED);

    if(active && !(portal->flags & PF_NORENDER) && !(sflags & PF_NORENDER))
        ret |= PS_VISIBLE;

    // Next two flags are for linked portals only
    active = (active && portal->type == R_LINKED && useportalgroups == true);

    if(active && !(portal->flags & PF_NOPASS) && !(sflags & PF_NOPASS))
        ret |= PS_PASSABLE;

    if(active && !(portal->flags & PF_BLOCKSOUND) && !(sflags & PF_BLOCKSOUND))
        ret |= PS_PASSSOUND;

    return ret;
}

void P_CheckRenderSectorPortalState(rendersector_t &sector, surf_e type)
{
    surface_t &surface = sector.srf[type];
    if(!surface.portal)
    {
        surface.pflags = 0;
        return;
    }
    bool obscured = surface.portal->type == R_LINKED && !(surface.pflags & PF_ATTACHEDPORTAL) &&
                    isInner(type, surface.height, surface.portal->data.link.planez);

    surface.pflags = P_GetPortalState(surface.portal, surface.pflags, obscured);
}
void P_CheckSectorPortalState(sector_t &sector, surf_e type)
{
    surface_t &surface = sector.srf[type];
    if(!surface.portal)
    {
        surface.pflags = 0;
        return;
    }
    fixed_t delta    = pSlopeHeights ? pSlopeHeights[&sector - sectors].delta[type] : 0;
    bool    obscured = surface.portal->type == R_LINKED && !(surface.pflags & PF_ATTACHEDPORTAL) &&
                    isInner(type, surface.height + delta, surface.portal->data.link.planez);

    surface.pflags = P_GetPortalState(surface.portal, surface.pflags, obscured);
}

void P_CheckLPortalState(line_t *line)
{
    if(!line->portal)
    {
        line->pflags = 0;
        return;
    }

    line->pflags = P_GetPortalState(line->portal, line->pflags, false);
}

//
// This function will set the floor or ceiling height, and update
// the float version of the floor or ceiling height as well. It also updates portals.
//
void P_SetRenderSectorHeight(rendersector_t &sec, surf_e surf, fixed_t h)
{
    surface_t &surface = sec.srf[surf];
    surface.height     = h;
    surface.heightf    = M_FixedToFloat(surface.height);

    // Update slope origin
    if(surface.slope)
    {
        surface.slope->o.z  = surface.height + surface.slope->surfaceZOffset;
        surface.slope->of.z = surface.heightf + surface.slope->surfaceZOffsetF;
    }

    // check portal state
    P_CheckRenderSectorPortalState(sec, surf);
}
void P_SetSectorHeight(sector_t &sec, surf_e surf, fixed_t h)
{
    surface_t &surface = sec.srf[surf];
    surface.height     = h;
    surface.heightf    = M_FixedToFloat(surface.height);

    // Update slope origin
    if(surface.slope)
    {
        surface.slope->o.z  = surface.height + surface.slope->surfaceZOffset;
        surface.slope->of.z = surface.heightf + surface.slope->surfaceZOffsetF;
    }

    // check portal state
    P_CheckSectorPortalState(sec, surf);
}

void P_SetPortalBehavior(portal_t *portal, int newbehavior)
{
    int i;

    portal->flags = newbehavior & PF_FLAGMASK;
    for(i = 0; i < numsectors; i++)
    {
        sector_t *sec = sectors + i;

        if(sec->srf.ceiling.portal == portal)
            P_CheckSectorPortalState(*sec, surf_ceil);
        if(sec->srf.floor.portal == portal)
            P_CheckSectorPortalState(*sec, surf_floor);
    }

    for(i = 0; i < numlines; i++)
    {
        if(lines[i].portal == portal)
            P_CheckLPortalState(lines + i);
    }
}

void P_SetFPortalBehavior(sector_t *sec, int newbehavior)
{
    if(!sec->srf.floor.portal)
        return;

    sec->srf.floor.pflags = newbehavior;
    P_CheckSectorPortalState(*sec, surf_floor);
}

void P_SetCPortalBehavior(sector_t *sec, int newbehavior)
{
    if(!sec->srf.ceiling.portal)
        return;

    sec->srf.ceiling.pflags = newbehavior;
    P_CheckSectorPortalState(*sec, surf_ceil);
}

void P_SetLPortalBehavior(line_t *line, int newbehavior)
{
    if(!line->portal)
        return;

    line->pflags = newbehavior;
    P_CheckLPortalState(line);
}

//
// Moves a polyobject portal cluster, updating link offsets.
//
void P_MoveGroupCluster(int outgroup, int ingroup, bool *groupvisit, fixed_t dx, fixed_t dy, bool setpolyref,
                        const polyobj_t *po)
{
    const int *row = clusters + ingroup * groupcount;
    for(int i = 0; i < groupcount; ++i)
    {
        if(groupvisit[i])
            continue;
        if(i != ingroup && (row[i] == -1 || row[i] == row[outgroup]))
            continue;
        groupvisit[i] = true;
        if(setpolyref)
            gGroupPolyobject[i] = po;

        for(int j = 0; j < groupcount; ++j)
        {
            if(row[j] != row[outgroup])
                continue;
            linkoffset_t *link = P_GetLinkOffset(j, i);
            if(link != &zerolink)
            {
                link->x -= dx;
                link->y -= dy;
            }

            // Make sure the backlink is aligned.
            linkoffset_t *backlink = P_GetLinkOffset(i, j);
            if(backlink != &zerolink)
            {
                backlink->x = -link->x;
                backlink->y = -link->y;
                backlink->z = -link->z;
            }
        }
    }
}

//
// Same as above, but generic
//
void P_ForEachClusterGroup(int outgroup, int ingroup, bool *groupvisit, bool (*func)(int groupid, void *context),
                           void *context)
{
    const int *row = clusters + ingroup * groupcount;
    for(int i = 0; i < groupcount; ++i)
    {
        if(groupvisit[i])
            continue;
        if(i != ingroup && (row[i] == -1 || row[i] == row[outgroup]))
            continue;

        groupvisit[i] = true;

        if(!func(i, context))
            return;
    }
}

//
// Returns a surface's portal Z, aware of whether it's an attached portal or not
//
fixed_t P_PortalZ(const surface_t &surface, fixed_t x, fixed_t y)
{
    // TODO: planez by coordinates (sloped portals)
    return !surface.portal || surface.portal->type != R_LINKED || surface.pflags & PF_ATTACHEDPORTAL ?
               surface.getZAt(x, y) :
               surface.portal->data.link.planez;
}

fixed_t P_PortalZ(const surface_t &surface)
{
    // TODO: real slopes and sloped portals
    return !surface.portal || surface.portal->type != R_LINKED || surface.pflags & PF_ATTACHEDPORTAL ?
               surface.height :
               surface.portal->data.link.planez;
}

//
// Builds the sector group mappings
//
void P_BuildSectorGroupMappings()
{
    Collection<PODCollection<int>> groupSectors;
    if(!useportalgroups)
        return;
    for(int i = 0; i < groupcount; ++i)
        groupSectors.add(PODCollection<int>());
    for(int i = 0; i < numsectors; ++i)
        groupSectors[sectors[i].groupid].add(i);
    gGroupSectors.load(groupSectors);
}

//
// Gets the collection of sectors for given group ID
//
const int *P_GetSectorsWithGroupId(int groupid, int *count)
{
    return gGroupSectors.getList(groupid, count);
}

//
// Gets the list of neighbors through a sector portal
//
const int *P_GetSectorPortalNeighbors(const sector_t &sector, surf_e surf, int *count)
{
    return gSectorNeighborsThroughPortals.getList(eindex(&sector - sectors), surf, count);
}

// EOF

