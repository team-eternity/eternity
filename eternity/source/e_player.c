// Emacs style mode select -*- C++ -*-
//----------------------------------------------------------------------------
//
// Copyright(C) 2006 James Haley
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//----------------------------------------------------------------------------
//
// EDF Player Class Module
//
// By James Haley
//
//----------------------------------------------------------------------------

#include "z_zone.h"
#include "p_skin.h"

#include "Confuse/confuse.h"

#define NEED_EDF_DEFINITIONS

#include "e_lib.h"
#include "e_edf.h"
#include "e_player.h"

#define ITEM_SKINSND_PAIN    "pain"
#define ITEM_SKINSND_DIEHI   "diehi"
#define ITEM_SKINSND_OOF     "oof"
#define ITEM_SKINSND_GIB     "gib"
#define ITEM_SKINSND_PUNCH   "punch"
#define ITEM_SKINSND_RADIO   "radio"
#define ITEM_SKINSND_DIE     "die"
#define ITEM_SKINSND_FALL    "fall"
#define ITEM_SKINSND_FEET    "feet"
#define ITEM_SKINSND_FALLHIT "fallhit"

static cfg_opt_t pc_skin_sound_opts[] =
{
   CFG_STR(ITEM_SKINSND_PAIN,    "plpain", CFGF_NONE),
   CFG_STR(ITEM_SKINSND_DIEHI,   "pdiehi", CFGF_NONE),
   CFG_STR(ITEM_SKINSND_OOF,     "oof",    CFGF_NONE),
   CFG_STR(ITEM_SKINSND_GIB,     "slop",   CFGF_NONE),
   CFG_STR(ITEM_SKINSND_PUNCH,   "punch",  CFGF_NONE),
   CFG_STR(ITEM_SKINSND_RADIO,   "radio",  CFGF_NONE),
   CFG_STR(ITEM_SKINSND_DIE,     "pldeth", CFGF_NONE),
   CFG_STR(ITEM_SKINSND_FALL,    "plfall", CFGF_NONE),
   CFG_STR(ITEM_SKINSND_FEET,    "plfeet", CFGF_NONE),
   CFG_STR(ITEM_SKINSND_FALLHIT, "fallht", CFGF_NONE),
};

#define ITEM_SKIN_SPRITE "sprite"
#define ITEM_SKIN_FACES  "faces"
#define ITEM_SKIN_SOUNDS "sounds"

static cfg_opt_t pc_skin_opts[] =
{
   CFG_STR(ITEM_SKIN_SPRITE, "PLAY",             CFGF_NONE),
   CFG_STR(ITEM_SKIN_FACES,  "STF",              CFGF_NONE),
   CFG_SEC(ITEM_SKIN_SOUNDS, pc_skin_sound_opts, CFGF_NOCASE),
   CFG_END()
};

#define ITEM_PCLASS_SKIN "skin"

cfg_opt_t edf_playerclass_opts[] =
{
   CFG_SEC(ITEM_PCLASS_SKIN, pc_skin_opts, CFGF_TITLE | CFGF_NOCASE),
   CFG_END()
};

//==============================================================================
// 
// Global Variables
//

// EDF Skins: These are skins created by the EDF player class objects. They will
// be added to the main skin list and fully initialized in p_skin.c along with
// other normal skins.

skin_t **edf_skins;
int numedfskins, numedfskinsalloc;


//==============================================================================
//
// Code
//

//
// E_AddPlayerClassSkin
//
// Adds a pointer to a skin generated by a player class to the reallocating
// array of pointers to EDF player class skins.
//
static void E_AddPlayerClassSkin(skin_t *skin)
{
   if(numedfskins >= numedfskinsalloc)
   {
      edf_skins = realloc(edf_skins, 
         (numedfskinsalloc = numedfskinsalloc ?
          numedfskinsalloc*2 : 4) * sizeof *edf_skins);
   }
   edf_skins[numedfskins] = skin;
   ++numedfskins;
}

//
// E_CreatePlayerClassSkin
//
// Creates and adds a new skin object for the player class. A pointer to the
// new skin is also returned so it can be stored in the player class.
//
static skin_t *E_CreatePlayerClassSkin(cfg_t *skinsec)
{
   skin_t *newSkin = malloc(sizeof(skin_t));
   cfg_t *sndsec;

   // skin name is section title
   newSkin->skinname = strdup(cfg_title(skinsec));

   E_EDFLogPrintf("\t\t* Creating skin '%s'\n", newSkin->skinname);

   // type is always player
   newSkin->type = SKIN_PLAYER;

   // set sprite information
   newSkin->spritename = strdup(cfg_getstr(skinsec, ITEM_SKIN_SPRITE));
   newSkin->sprite     = 0;  // handled by skin code

   // set faces
   newSkin->facename = strdup(cfg_getstr(skinsec, ITEM_SKIN_FACES));
   newSkin->faces    = NULL; // handled by skin code
   
   // set sounds
   if(cfg_size(skinsec, ITEM_SKIN_SOUNDS) <= 0)
   {
      // section is not optional, and error is not recoverable
      E_EDFLoggedErr(2, "E_CreatePlayerClassSkin: required sounds section "
                        "is missing for skin '%s'\n", newSkin->skinname);
   }
   sndsec = cfg_getsec(skinsec, ITEM_SKIN_SOUNDS);

   // get sounds from the sounds section
   newSkin->sounds[sk_plpain] = strdup(cfg_getstr(sndsec, ITEM_SKINSND_PAIN));
   newSkin->sounds[sk_pdiehi] = strdup(cfg_getstr(sndsec, ITEM_SKINSND_DIEHI));
   newSkin->sounds[sk_oof]    = strdup(cfg_getstr(sndsec, ITEM_SKINSND_OOF));
   newSkin->sounds[sk_slop]   = strdup(cfg_getstr(sndsec, ITEM_SKINSND_GIB));
   newSkin->sounds[sk_punch]  = strdup(cfg_getstr(sndsec, ITEM_SKINSND_PUNCH));
   newSkin->sounds[sk_radio]  = strdup(cfg_getstr(sndsec, ITEM_SKINSND_RADIO));
   newSkin->sounds[sk_pldeth] = strdup(cfg_getstr(sndsec, ITEM_SKINSND_DIE));
   newSkin->sounds[sk_plfall] = strdup(cfg_getstr(sndsec, ITEM_SKINSND_FALL));
   newSkin->sounds[sk_plfeet] = strdup(cfg_getstr(sndsec, ITEM_SKINSND_FEET));
   newSkin->sounds[sk_fallht] = strdup(cfg_getstr(sndsec, ITEM_SKINSND_FALLHIT));

   // add the skin to the list
   E_AddPlayerClassSkin(newSkin);

   // return the new skin
   return newSkin;
}

//
// E_ProcessPlayerClass
//
// Processes a single EDF player class section.
//
static void E_ProcessPlayerClass(cfg_t *pc)
{
   const char *tempstr;

   // get mnemonic (section title)
   tempstr = cfg_title(pc);

   E_EDFLogPrintf("\t\tProcessing class %s\n", tempstr);

   // process skin -- required element
   if(cfg_size(pc, ITEM_PCLASS_SKIN) <= 0)
   {
      E_EDFLoggedErr(2, "E_ProcessPlayerClass: required skin is missing for "
                        "player class"); // FIXME: print mnemonic
   }
   E_CreatePlayerClassSkin(cfg_getsec(pc, ITEM_PCLASS_SKIN));
}

//
// E_ProcessPlayerClasses
//
// Processes all EDF player classes.
//
void E_ProcessPlayerClasses(cfg_t *cfg)
{
   unsigned int count, i;

   count = cfg_size(cfg, EDF_SEC_PCLASS);

   E_EDFLogPrintf("\t* Processing player classes\n"
                  "\t\t%d class(es) defined\n", count);

   for(i = 0; i < count; ++i)
      E_ProcessPlayerClass(cfg_getnsec(cfg, EDF_SEC_PCLASS, i));
}

// EOF


